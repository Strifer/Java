package hr.fer.zemris.java.custom.scripting.exec;

import java.io.IOException;
import java.util.Stack;

import hr.fer.zemris.java.custom.scripting.nodes.DocumentNode;
import hr.fer.zemris.java.custom.scripting.nodes.EchoNode;
import hr.fer.zemris.java.custom.scripting.nodes.ForLoopNode;
import hr.fer.zemris.java.custom.scripting.nodes.INodeVisitor;
import hr.fer.zemris.java.custom.scripting.nodes.TextNode;
import hr.fer.zemris.java.custom.scripting.tokens.Token;
import hr.fer.zemris.java.webserver.RequestContext;

/**
 * This class enables the execution of <code>SmartScript</code> scripts.
 * <code>SmartScript</code> scripts can be used to write simple rudimentary
 * programs by using their three main components, for loops, functions and
 * operations.
 * <p>
 * Current supported operations are: addition, subtraction, division and
 * multiplication. <br>
 * 
 * @author Filip Džidić
 *
 */
public class SmartScriptEngine {
	/**
	 * the document node generated by parsing through <code>SmartScript</code>
	 * scripts
	 */
	private DocumentNode documentNode;
	/** the <code>RequestContext</code> used for gnerating HTTP requests */
	private RequestContext requestContext;

	/**
	 * helper multistack used for keeping parameters and enabling nested for
	 * loops
	 */
	private ObjectMultistack multistack = new ObjectMultistack();

	/**
	 * This main visitor visits every element of the parsed script in
	 * DocumentNode and performs the proper execution defined by the script.
	 */
	private INodeVisitor visitor = new INodeVisitor() {

		@Override
		public void visitTextNode(TextNode node) {
			try {
				requestContext.write(node.getText());
			} catch (IOException exception) {
				System.err.println("Cannot write to file stream");
				return;
			}

		}

		@Override
		public void visitForLoopNode(ForLoopNode node) {
			String varName = node.getVariable().asText();
			String initVal = node.getStartExpression().asText();
			String stepVal = node.getStepExpression() == null ? "1" : node
					.getStepExpression().asText();
			String endVal = node.getEndExpression().asText();
			int childrenNum = node.numberOfChildren();

			multistack.push(varName, new ValueWrapper(initVal));
			while (multistack.peek(varName).numCompare(endVal) <= 0) {
				for (int i = 0; i < childrenNum; i++) {
					node.getChild(i).accept(this);
				}
				multistack.peek(varName).increment(stepVal);
			}
			multistack.pop(varName);

		}

		@Override
		public void visitEchoNode(EchoNode node) {
			Stack<Object> stack = new Stack<>();
			Token[] tokens = node.getTokens();
			for (Token token : tokens) {
				switch (token.getClass().getSimpleName()) {
					case "TokenVariable":
						stack.push(multistack.peek(token.asText()).getValue());
						break;

					case "TokenOperator":
						Object second = stack.pop();
						ValueWrapper first = new ValueWrapper(stack.pop());
						EngineUtility.operations.get(token.asText())
								.performOperation(first, second);
						stack.push(first.getValue());
						break;

					case "TokenFunction":
						EngineUtility.functions.get(token.asText()).operate(
								stack, requestContext);
						break;

					case "TokenString":
						// my SmartScriptParser is dumb so I have to do this
						// I don't recommend looking in that horrible
						// SmartScriptParser mess if you
						// value your sanity
						stack.push(token.asText().replace("\"", "")
								.replaceAll("\\\\r", "\r")
								.replaceAll("\\\\n", "\n"));
						break;
					default:
						stack.push(new ValueWrapper(token.asText()).getValue());

				}
			}

			if (!stack.isEmpty()) {
				stack = reverseStack(stack);
				while (!stack.isEmpty()) {
					try {
						requestContext.write(stack.pop().toString());
					} catch (IOException e) {
						System.err.println("Cannot write to file stream");
						return;
					}
				}
			}

		}

		@Override
		public void visitDocumentNode(DocumentNode node) {
			for (int i = 0, numChildren = node.numberOfChildren(); i < numChildren; i++) {
				node.getChild(i).accept(this);
			}

		}

		private Stack<Object> reverseStack(Stack<Object> stack) {
			Stack<Object> revStack = new Stack<Object>();
			while (!stack.isEmpty()) {
				revStack.push(stack.pop());
			}
			return revStack;
		}

	};

	/**
	 * Constructs a new instance of <code>SmartScriptEngine</code> capable of
	 * executing the provided script
	 * 
	 * @param documentNode
	 *            the parsed <code>SmartScript</code>
	 * @param requestContext
	 *            the <code>RequestContext</code> used for generating HTTP
	 *            requests using the script
	 */
	public SmartScriptEngine(DocumentNode documentNode,
			RequestContext requestContext) {
		this.documentNode = documentNode;
		this.requestContext = requestContext;
	}

	/**
	 * Executes the script.
	 */
	public void execute() {
		documentNode.accept(visitor);
	}

}
